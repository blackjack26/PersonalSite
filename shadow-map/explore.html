<!DOCTYPE html>
<html style="overflow: hidden;">
<head>
    <meta charset="UTF-8" />

    <link rel="stylesheet" type="text/css" href="css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="css/bulma.css" />
    <link rel="stylesheet" type="text/css" href="css/explore.css" />

    <!-- Default Shaders -->
    <script type="x-shader/x-vertex" id="vertex-shader">
        attribute vec3 position; // the position of the point
        attribute vec2 uv;
        attribute vec3 normal;

        uniform mat4 vMatrix;
        uniform mat4 pMatrix;
        uniform mat4 mMatrix;

        uniform mat4 lMatrix;
        uniform mat4 pMatrixLight;

        varying vec2 vUV;
        varying vec3 vNormal;
        varying vec3 vView;
        varying vec3 vLightPos;

        void main(void) {
            vec4 lightPos = pMatrixLight * lMatrix * mMatrix * vec4(position, 1.0);
            vec3 lightPosDNC = lightPos.xyz / lightPos.w;
            vLightPos = vec3(0.5, 0.5, 0.5) + lightPosDNC * 0.5;

            gl_Position = pMatrix * vMatrix * mMatrix * vec4(position, 1.0);
            vNormal = normalize(vec3(mMatrix * vec4(normal, 0.0)));
            vView = vec3(vMatrix * mMatrix * vec4(position, 1.0));
            vUV = uv;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragment-shader">
        precision mediump float;

        uniform sampler2D sampler;
        uniform sampler2D samplerShadowMap;
        uniform vec3 sourceDirection;
        uniform int filterType;
        uniform float tolerance;

        varying vec2 vUV;
        varying vec3 vNormal;
        varying vec3 vView;
        varying vec3 vLightPos;

        const vec3 sourceAmbientColor = vec3(1.0, 1.0, 1.0);
        const vec3 sourceDiffuseColor = vec3(1.0, 1.0, 1.0);
        const vec3 sourceSpecularColor = vec3(1.0, 1.0, 1.0);

        const vec3 matAmbientColor = vec3(0.3, 0.3, 0.3);
        const vec3 matDiffuseColor = vec3(1.0, 1.0, 1.0);
        const vec3 matSpecularColor = vec3(1.0, 1.0, 1.0);
        const float matShininess = 15.0;

        float variance(vec4 shadowMapColor) {
            float variance = shadowMapColor.g - shadowMapColor.r * shadowMapColor.r;
            variance = max(variance, tolerance);

            float d = shadowMapColor.r - vLightPos.z;
            return variance / (variance + d * d);
        }

        float pcf(vec2 uvShadowMap) {
            float sum = 0.0;
            vec2 duv;
            for (float pcfX = -1.5; pcfX <= 1.5; pcfX += 1.0) {
                for (float pcfY = -1.5; pcfY <= 1.5; pcfY += 1.0) {
                    duv = vec2(pcfX / 512.0, pcfY / 512.0);
                    sum += texture2D(samplerShadowMap, uvShadowMap + duv).r;
                }
            }
            sum /= 16.0;
            return 1.0 - smoothstep(0.001, 0.04, vLightPos.z - sum);
        }

        float getShadow(vec4 shadowMapColor) {
            float zShadowMap = shadowMapColor.r;
            float shadowCoeff = 1.0 - (vLightPos.z - zShadowMap);
            // Shadow Acne
            if (zShadowMap + tolerance < vLightPos.z) {
                shadowCoeff = 0.0;
            }
            return shadowCoeff;
        }

        void main(void) {
            vec2 uvShadowMap = vLightPos.xy;
            vec4 shadowMapColor = texture2D(samplerShadowMap, uvShadowMap);

            float shadowCoeff = 0.0;
            if (filterType == 1) {
                shadowCoeff = pcf(uvShadowMap);
            } else if (filterType == 2) {
                shadowCoeff = variance(shadowMapColor);
            } else {
                shadowCoeff = getShadow(shadowMapColor);
            }

            vec3 color = vec3(texture2D(sampler, vUV));
            vec3 iAmbient = sourceAmbientColor * matAmbientColor;
            vec3 iDiffuse = sourceDiffuseColor * matDiffuseColor * max(0.0, dot(vNormal, sourceDirection));
            vec3 v = normalize(vView);
            vec3 r = reflect(sourceDirection, vNormal);
            vec3 iSpecular = sourceSpecularColor * matSpecularColor * pow(max(dot(r, v), 0.0), matShininess);
            vec3 i = iAmbient + shadowCoeff * (iDiffuse + iSpecular);
            gl_FragColor = vec4(i*color, 1.0);
        }
    </script>

    <!-- Shadow Map Shaders -->
    <script type="x-shader/x-vertex" id="shadow-vertex">
        attribute vec3 position;

        uniform mat4 pMatrix, lMatrix, mMatrix;

        varying float vDepth;

        void main(void) {
            vec4 p = pMatrix * lMatrix * mMatrix * vec4(position, 1.0);
            float zBuf = p.z / p.w;
            vDepth = 0.5 + zBuf * 0.5;
            gl_Position = p;
        }
    </script>
    <script type="x-shader/x-fragment" id="shadow-fragment">
        #extension GL_OES_standard_derivatives : enable
        precision mediump float;

        varying float vDepth;

        uniform int filterType;

        void main(void) {
            // Variance Shadow Mapping
            if (filterType == 2) {
                float depth2 = vDepth * vDepth;
                float dx = dFdx(vDepth);
                float dy = dFdy(vDepth);
                float depth2Avg = depth2 + 0.25 * (dx * dx + dy * dy);
                gl_FragColor = vec4(vDepth, depth2Avg, 0.0, 1.0);
            } else {
                gl_FragColor = vec4(vDepth, 0.0, 0.0, 1.0);
            }
        }
    </script>

    <script type="text/javascript" src="Libs.js"></script>
    <script type="text/javascript" src="Camera.js"></script>
    <script type="text/javascript" src="Shader.js"></script>
    <script type="text/javascript" src="Mesh.js"></script>
    <script type="text/javascript" src="main.js"></script>
</head>
<body style="margin: 0;">
    <section class="hero is-dark is-bold is-fullheight">
        <canvas id="gl_canvas" style='position: absolute; background-color: black;'></canvas>
    </section>
    <div id="toolbar" class="card" style="box-shadow: 0 2px 5px rgba(0,0,0, 0.5)">
        <div class="card-header" id="tool-header">
            <p class="card-header-title">Scene Tools</p>
        </div>
        <div class="card-content">

            <!-- Filter -->
            <div class="field">
                <label class="label">Filter</label>
                <div class="control">
                    <label class="radio">
                        <input type="radio" name="filter" checked onclick="setFilter(0)">
                        None
                    </label>
                    <label class="radio">
                        <input type="radio" name="filter" onclick="setFilter(1)">
                        PCF
                    </label>
                    <label class="radio">
                        <input type="radio" name="filter" onclick="setFilter(2)">
                        Variance
                    </label>
                </div>
                <p id="tolerance-div" class="control has-icons-left">
                    <input id="tolerance" class="input" type="number" min="-1" max="1" step="0.0005" onchange="setTolerance()" value="0.002">
                    <span class="icon is-small is-left">T</span>
                </p>
            </div>

            <!-- Quality -->
            <div class="field">
                <label class="label">Quality</label>
                <div class="control">
                    <label class="radio">
                        <input type="radio" name="quality" checked onclick="setQuality(20)">
                        High
                    </label>
                    <label class="radio">
                        <input type="radio" name="quality" onclick="setQuality(50)">
                        Average
                    </label>
                    <label class="radio">
                        <input type="radio" name="quality" onclick="setQuality(80)">
                        Low
                    </label>
                </div>
            </div>

            <!-- Depth Map -->
            <div class="field">
                <label class="label">Depth Map</label>
                <button id="depth-map-btn" class="button is-dark" onclick="toggleShadowMap(this)">Show</button>
            </div>

            <!-- Light Direction -->
            <div class="field">
                <label class="label">Light Direction</label>
                <p class="control has-icons-left">
                    <input id="lightX" class="input" type="number" min="-1" max="1" step="0.1" onchange="setLightDir()" value="0.5">
                    <span class="icon is-small is-left">X</span>
                </p>
                <p class="control has-icons-left">
                    <input id="lightY" class="input" type="number" min="0" max="1" step="0.1" onchange="setLightDir()" value="0.5">
                    <span class="icon is-small is-left">Y</span>
                </p>
                <p class="control has-icons-left">
                    <input id="lightZ" class="input" type="number" min="-1" max="1" step="0.1" onchange="setLightDir()" value="-0.5">
                    <span class="icon is-small is-left">Z</span>
                </p>
            </div>
        </div>
    </div>

    <div id="code-view" class="card" style="box-shadow: 0 2px 5px rgba(0,0,0, 0.5)">
        <div class="card-header" id="code-header">
            <p class="card-header-title">Code View</p>
        </div>
        <div class="card-content">

            <div id="no-filter-code" class="code">
                <p style="color: #AAAAAA"><i>Fragment Shader</i></p><br />
                <span class="type">float</span> zShadowMap = shadowMapColor.<b>r</b>;<br />
                <span class="type">float</span> shadowCoeff = 1.0 - (vLightPos.z - zShadowMap);<br />
                <span class="keyword">if</span> (zShadowMap + <span class="tolerance">0.002</span> < vLightPos.z) { <br />
                &nbsp;&nbsp;&nbsp;&nbsp;shadowCoeff = 0.0;<br />
                }<br />
                <span class="keyword">return</span> shadowCoeff;
            </div>

            <div id="pcf-filter-code" class="code" style="display: none">
                <p style="color: #AAAAAA"><i>Fragment Shader</i></p><br />
                <span class="type">float</span> sum = 0.0;<br />
                <span class="type">vec2</span> duv;<br />
                <span class="keyword">for</span> (<span class="type">float</span> pcfX = -1.5; pcfX <= 1.5; pcfX += 1.0) {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span> (<span class="type">float</span> pcfY = -1.5; pcfY <= 1.5; pcfY += 1.0) {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duv = <span class="type">vec2</span>(pcfX / 512.0, pcfY / 512.0);<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += <span class="type">texture2D</span>(samplerShadowMap, uvShadowMap + duv).<b>r</b>;<br />
                &nbsp;&nbsp;&nbsp;&nbsp;}<br />
                }<br />
                sum /= 16.0;<br />
                <span class="keyword">return</span> 1.0 - smoothstep(0.001, 0.04, vLightPos.z - sum);
            </div>

            <div id="var-filter-code" class="code" style="display: none">
                <p style="color: #AAAAAA"><i>Fragment Shader</i></p><br />
                <span class="type">float</span> variance = shadowMapColor.<b>g</b> - shadowMapColor.<b>r</b> * shadowMapColor.<b>r</b>;<br />
                variance = max(variance, <span class="tolerance">0.002</span>);<br />
                <span class="type">float</span> d = shadowMapColor.r - vLightPos.z;<br />
                <span class="keyword">return</span> variance / (variance + d * d);<br />
                <br />

                <p style="color: #AAAAAA"><i>Shadow Fragment Shader</i></p><br />
                <span class="type">float</span> depth2 = vDepth * vDepth;<br />
                <span class="type">float</span> dx = dFdx(vDepth);<br />
                <span class="type">float</span> dy = dFdy(vDepth);<br />
                <span class="type">float</span> depth2Avg = depth2 + 0.25 * (dx * dx + dy * dy);<br />
                gl_FragColor = <span class="type">vec4</span>(vDepth, depth2Avg, 0.0, 1.0);<br />
            </div>
        </div>
    </div>

    <div id="notification" class="card">
        <div class="card-content">
            <p>
                <span class="fa fa-info-circle"></span><br />
                <span id="not-msg">
                    The normal shadow map uses a depth buffer, or z-buffer to calculate a shadow coefficient. This is a
                    number between 0 and 1 indicating how much of the pixel's color should be displayed. 0 means a full
                    shadow and 1 means no shadow. The shadow map is stored in a renderbuffer as a texture to be rendered
                    onto the scene.
                </span>
            </p>
        </div>
    </div>

    <button class="button is-dark" id="home-btn" onclick="goHome()"><span class="fa fa-caret-left"></span>&nbsp;&nbsp;Home</button>
</body>
<script type="text/javascript">
    window.onload = function() {
        init();

        // Fade windows in
        document.getElementById('gl_canvas').classList.add('show');
        setTimeout(function() {
            document.getElementById('toolbar').classList.add('show');
        }, 400);
        setTimeout(function() {
            document.getElementById('code-view').classList.add('show');
        }, 800);
        setTimeout(function() {
            document.getElementById('notification').classList.add('show');
        }, 1200);

        // Draggable windows
        const toolbar = document.querySelector('#toolbar .card-header');
        toolbar.onmousedown = function(e) {
            this.mouseDown = true;
            this.startPos = {
                x: e.pageX,
                y: e.pageY,
            };
        };

        const code = document.querySelector('#code-view .card-header');
        code.onmousedown = function(e) {
            this.mouseDown = true;
            this.startPos = {
                x: e.pageX,
                y: e.pageY,
            };
        };

        window.onmouseup = function(e) {
            toolbar.mouseDown = false;
            code.mouseDown = false;
        };
        window.onmousemove = function(e) {
            if (toolbar.mouseDown) {
                const x = e.pageX - toolbar.startPos.x;
                const y = e.pageY - toolbar.startPos.y;
                toolbar.startPos = {
                    x: e.pageX,
                    y: e.pageY,
                };

                const tbar = document.getElementById('toolbar');
                const left = tbar.style.left.replace(/px/g, '');
                const top = tbar.style.top.replace(/px/g, '');
                tbar.style.left = `${Number(left) + x}px`;
                tbar.style.top = `${Number(top) + y}px`;
            }
            else if (code.mouseDown) {
                const x = e.pageX - code.startPos.x;
                const y = e.pageY - code.startPos.y;
                code.startPos = {
                    x: e.pageX,
                    y: e.pageY,
                };

                const cview = document.getElementById('code-view');
                const right = cview.style.right.replace(/px/g, '');
                const top = cview.style.top.replace(/px/g, '');
                cview.style.right = `${Number(right) - x}px`;
                cview.style.top = `${Number(top) + y}px`;
            }
        };
    };

    function goHome() {
        document.getElementById('gl_canvas').classList.remove('show');
        document.getElementById('toolbar').classList.remove('show');
        document.getElementById('code-view').classList.remove('show');
        document.getElementById('notification').classList.remove('show');
        setTimeout(function() {
            window.location.href = "index.html";
        }, 1000);
    }
</script>
</html>